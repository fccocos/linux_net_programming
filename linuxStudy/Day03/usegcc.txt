gcc -fPIC(生成与位置无关的代码段) -c(生成目标文件.o文件) -Ipath（指定文件生成路径）
gcc -shared(共享) lib+name+.so -o 需要打包的目标文件.o文件 -Ipath
gcc main.c libdynamic.so -o appname -Ipath
gcc main.c -Ipath -L动态库的路径 -l动态库
ldd 查看程序所依赖的共享库
动态连接器，根据环境变量来查找动态库 
echo $PATH
1. 将生成的动态库复制到\lib中（不推荐使用）
2. LD_LIBRARY_PATH（动态库环境变量）(在开发过程中，对动态库进行测试时使用)
   echo $LD_LIBRARY_PATH
   export LD_LIBRARY_PATH=./lib
3. .bashrc文件中写入export LD_LIBRARY_PATH=动态库的绝对路径
4. 1)找到动态库连接器的配置文件 vim /etc/ld.so.conf
   2）动态库的路径写到配置文件中 写入动态库的绝对路径
   3）更新--sudo ldconfig -v  
动态库的优点：
   1. 执行程序小
   2. 动态库更新了，不需要重新编译
缺点：
   1. 发布程序的时候，需要将动态库发布给用户

   2. 执行效率相对较低

gcc工作流程 
1. 预处理 gcc -E
2. 编译 gcc -S
3. 汇编 gcc -c
4. 链接 没有文件

-o 指定生成文件的名字
-D z在编译的时候定义宏（控制log输出）
-I 指定头文件路径
-g gdb调试时候需要添加该参数
-O 编译优化，3个等级(1-3)
-Wall 编译期间输出警告

静态库
1. 命名规则：libname.a
2. 制作步骤：
 1. 生成.o
	gcc -c *.c
 2. 打包（所有的.o文件）
	ar rcs 静态库的名字 *.o
 3. 使用：main.c -L -l
    gcc main.c  -Llibpath -llibname -o appname -Iinclude

动态库
1. 动态库命名 libname.so
2. 制作步骤：
	1. 生成与位置无关的代码（.o） gcc -fPIC -c *.c -Iinclude
	2. 将.o打包生成.so文件 gcc -shared *.o -o libname.so
3. 使用：main.c lib include
	gcc main.c -Llib -lname -Iinclude -o appname
	
程序无法使用，由于动态库连接器连接不到自己制作的库
1. 临时设置 export LD_LIBRARY_PATH=动态库路径
2. 永久设置 
 1. 找到动态库配置文件 /etc/ld.so.conf
 2. 写入动态库目录（绝对路径）
 3. 更新 sudo ldconfig -v



gdb调试
1. gcc -g 加入调试信息
2. gdb 程序
3. l 查看源文件 l numbers | l filename:number（function） | l function
4. b(break) 打断点 b numbers(function) | b filename:number(function)
5. display 跟踪显示值  undisplay 取消跟踪变量
6. p(print) 查看值类型 ptype 查看变量类型
7. s(step) 单步（跳到函数内部）
8. c(contiue) 继续运行
9. n(next) 单步（执行下一行）
8. i(info) 查看调试信息 i b 查看断点信息 
9. run start--只执行一步
10. d(delete) d 断点编号 i(info) b 获取断点编号 | 删除断点
11. u 退出当前循环
12. set var 变量名=值  | 设置变量值
13. info display | 查看跟踪变量的信息
